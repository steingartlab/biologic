
// MFCSampleDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MFCSample.h"
#include "MFCSampleDlg.h"
#include "afxdialogex.h"

#pragma comment(lib, "EClib64.lib")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define MAX_CHANNELS (16)

UINT UWM_UPDATE_RESULTS    = RegisterWindowMessage (L"ECLIB_UPDATE_RESULTS");
UINT UWM_POPULATE_FINISHED = RegisterWindowMessage (L"ECLIB_POPULATE_FINISHED");
UINT UWM_MESSAGE_RECEIVED  = RegisterWindowMessage (L"UWM_MESSAGE_RECEIVED");

// path to the ECC and FW files
static CString eclab_path(L"..\\..\\..\\..\\..\\..\\EC-Lab Development Package\\");

// used by the main window to pass work data to the threads
typedef struct {
    HWND             hwnd;
    INT32            conn_id;
    bool             vmp4;
    uint8            channel;
    bool*            stop;
}ThreadWork;

// used by the threads to send back data to the main window
typedef struct {
    int total;
    TDataBuffer_t buf;
    TCurrentValues_t curr;
    TDataInfos_t infos;
} ThreadWorkData;

// identifies the thread
typedef enum {
    DATA_THREAD,
    MESSAGE_THREAD
} ThreadId ;

// returns true if the device ID corresponds to the vmp4 technology
static bool is_vmp4( INT32 device_id ){
    static const TDeviceType_e vmp4_devices[] = {
        KBIO_DEV_SP200, KBIO_DEV_SP300,
        KBIO_DEV_VSP300, KBIO_DEV_VMP300, KBIO_DEV_SP240
    };

    bool vmp4 = false;
    for( int i=0; i<sizeof(vmp4_devices)/sizeof(TDeviceType_e); i++){
        if( device_id == vmp4_devices[i] ){
            vmp4 = true;
            break;
        }
    }
    return vmp4;
}

CMFCSample::CMFCSample(CWnd* pParent /*=NULL*/)
    : CDialogEx(CMFCSample::IDD, pParent)
    , conn_id( -1 )
    , stop_acq( false )
    , stop_messages( false )
    , data_thread_handle( 0 ) 
    , msg_thread_handle( 0 ) 
{
}

CMFCSample::~CMFCSample(){
    OnDisconnectClicked();
}

BEGIN_MESSAGE_MAP(CMFCSample, CDialogEx)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_REGISTERED_MESSAGE( UWM_UPDATE_RESULTS, &CMFCSample::OnUpdateData )
    ON_REGISTERED_MESSAGE( UWM_POPULATE_FINISHED, &CMFCSample::OnPopulateFinished )
    ON_REGISTERED_MESSAGE( UWM_MESSAGE_RECEIVED, &CMFCSample::OnVMPMessage )
    ON_BN_CLICKED(IDC_BUTTON_QUIT, &CMFCSample::OnQuitClicked)
    ON_BN_CLICKED(IDC_BUTTON_CONNECT, &CMFCSample::OnConnectClicked)
    ON_BN_CLICKED(IDC_BUTTON_INFO, &CMFCSample::OnInfoClicked)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT, &CMFCSample::OnDisconnectClicked)
    ON_BN_CLICKED(IDC_BUTTON_CHAN_INFO, &CMFCSample::OnChanInfoClicked)
    ON_BN_CLICKED(IDC_BUTTON_CHAN_CURRENT_VALUES, &CMFCSample::OnChanCurrentValueClicked)
    ON_BN_CLICKED(IDC_BUTTON_START, &CMFCSample::OnStartClicked)
    ON_BN_CLICKED(IDC_BUTTON_STOP, &CMFCSample::OnStopClicked)
    ON_BN_CLICKED(IDC_BUTTON_COPY, &CMFCSample::OnBnClickedButtonCopy)
    ON_CBN_SELCHANGE(IDC_COMBO_CHANNELS, &CMFCSample::OnChannelSelectionChanged)
END_MESSAGE_MAP()

// automatically generated by VC
void CMFCSample::DoDataExchange(CDataExchange* pDX){
    CDialogEx::DoDataExchange( pDX );
    DDX_Control(pDX, IDC_EDIT_IP,           ip_address);
    DDX_Control(pDX, IDC_BUTTON_CONNECT,    connect_btn);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT, disconnect_btn);
    DDX_Control(pDX, IDC_BUTTON_START,      start_btn);
    DDX_Control(pDX, IDC_BUTTON_STOP,       stop_btn);
    DDX_Control(pDX, IDC_BUTTON_QUIT,       quit_btn);
    DDX_Control(pDX, IDC_BUTTON_INFO,       info_btn);
    DDX_Control(pDX, IDC_CONNECTION_STATUS, conn_status);
    DDX_Control(pDX, IDC_STARTED_STATUS,    started_status);
    DDX_Control(pDX, IDC_COMBO_CHANNELS,    channel_list);
    DDX_Control(pDX, IDC_COMBO2,            techniques_list);
    DDX_Control(pDX, IDC_EDIT_LOG,          logmsg);
    DDX_Control(pDX, IDC_EDIT_POINT_COUNT,  point_count);
    DDX_Control(pDX, IDC_CHECK_RELOAD_FW,   firmware_checkbox);
    DDX_Control(pDX, IDC_LIST2,             list_ctrl);
    DDX_Control(pDX, IDC_SHOW_PARAMS,       show_params);
    DDX_Control(pDX, IDC_XREC_CE, xrec_ce);
    DDX_Control(pDX, IDC_XREC_AUX1, xrec_aux1);
    DDX_Control(pDX, IDC_XREC_AUX2, xrec_aux2);
    DDX_Control(pDX, IDC_XREC_Q, xrec_q);
    DDX_Control(pDX, IDC_XREC_IRANGE, xrec_irange);
    DDX_Control(pDX, IDC_XREC_CTRL, xrec_ctrl);
}

BOOL CMFCSample::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    ip_address.SetWindowTextW(TEXT("192.109.209.229"));
    ip_address.SetFocus();

    int idx = techniques_list.AddString(TEXT("OCV"));
    techniques_list.AddString(TEXT("ChronoPotentiometry"));
    techniques_list.AddString(TEXT("ChronoAmperometry"));
    techniques_list.SetCurSel(idx);

    logmsg.SetWindowTextW( L"==== LOG ====\n\r\n" );
    
    return TRUE;
}

void CMFCSample::DisplayPopup( const CString &message, BOOL fatal){
    AfxMessageBox(message,  MB_OK);
    if( fatal )
        PostQuitMessage(-1);
}

void CMFCSample::DisplayPopupDisconnect( CString message, int err ) {
    CString error;
    error.Format(L" - Error: %d", err );
    message += error;
    AfxMessageBox(message,  MB_OK);
    OnDisconnectClicked();
}
int  CMFCSample::getXrec(){
    int xrec = 0;

    if( BST_CHECKED == xrec_ce.GetCheck() )
        xrec |= XREC_CE;
    if( BST_CHECKED == xrec_aux1.GetCheck() )
        xrec |= XREC_AUX1;
    if( BST_CHECKED == xrec_aux2.GetCheck() )
        xrec |= XREC_AUX2;
    if( BST_CHECKED == xrec_ctrl.GetCheck() )
        xrec |= XREC_CTL;
    if( BST_CHECKED == xrec_q.GetCheck() )
        xrec |= XREC_Q;
    if( BST_CHECKED == xrec_irange.GetCheck() )
        xrec |= XREC_IRG;

    return xrec;
}
void CMFCSample::setupChannels(){
    uint8 len = MAX_CHANNELS;
    uint8 channels[MAX_CHANNELS];
    int  results[MAX_CHANNELS];

    int err = BL_GetChannelsPlugged( conn_id, channels, len );
    if( err == ERR_NOERROR ){
        CString number;
        for( uint8 i=0; i<len; ++i){
            if( channels[i] ){
                number.Format( L"%3d", i);
                channel_list.AddString( number );
            }
        }
        channel_list.SetCurSel(0); // select the first item
        CString fw_file = eclab_path + (is_vmp4(infos.DeviceCode) ? L"kernel4.bin" : L"kernel.bin");
        CString xlx_file = eclab_path + (is_vmp4(infos.DeviceCode) ? L"Vmp_iv_0395_aa.xlx" : L"Vmp_ii_0437_a6.xlx");

        if( channel_list.GetCount() == 0 ) // no channel connected
        {
            DisplayPopupDisconnect(L"No channels connected, disconnect" );
            return;
        }

        bool force_fw_reload = ( BST_CHECKED == firmware_checkbox.GetCheck() );
        err = BL_LoadFirmware( conn_id, channels, results, len, true, force_fw_reload, CStringA(fw_file), CStringA(xlx_file) );
        if( err != ERR_NOERROR ) {
            DisplayPopupDisconnect(L"BL_LoadFirmware failed.", err );
        }
    } else {
        DisplayPopupDisconnect(L"BL_GetChannelsPlugged failed with error %d", err );
    }
}

void CMFCSample::setupDataList( const CString &technique, bool vmp4, int xrec )
{
    int idx = 0;
    // reset data field
    list_ctrl.DeleteAllItems();
    while( list_ctrl.DeleteColumn(0) ); // will destroy all the columns

    list_ctrl.InsertColumn(idx++, L"#", 0, 80 );
    list_ctrl.InsertColumn(idx++, L"Time (s)", 0, 80);
    list_ctrl.InsertColumn(idx++, L"Ewe (V)", 0, 80);

    if( technique == "OCV" && !vmp4 ) {
        list_ctrl.InsertColumn(idx++,L"Ece (V)", 0, 80);
    } else if (technique == "ChronoPotentiometry" 
            || technique == "ChronoAmperometry" ) {
        list_ctrl.InsertColumn(idx++, L"I (A)", 0, 80);
        list_ctrl.InsertColumn(idx++, L"Cycle", 0, 80);
    }

    if( xrec & XREC_CE )  list_ctrl.InsertColumn(idx++, L"CE (V)",   0, 80);
    if( xrec & XREC_AUX1) list_ctrl.InsertColumn(idx++, L"AUX1 (V)", 0, 80);
    if( xrec & XREC_AUX2) list_ctrl.InsertColumn(idx++, L"AUX2 (V)", 0, 80);
    if( xrec & XREC_CTL)  list_ctrl.InsertColumn(idx++, L"CTRL (V)", 0, 80);
    if( xrec & XREC_Q )   list_ctrl.InsertColumn(idx++, L"Q (C)",    0, 80);
    if( xrec & XREC_IRG ) list_ctrl.InsertColumn(idx++, L"IRange",   0, 80);
}

uint8 CMFCSample::getCurrentChannel(){
    CString channel;
    TCHAR *end = NULL;
    channel_list.GetLBText(channel_list.GetCurSel(), channel);

    uint8 c = (uint8)_tcstol(channel, &end, 10);
    if( channel.IsEmpty() ){
        // conversion failed
        c = -1;
    }
    return c;
}

HANDLE CMFCSample::createThread( AFX_THREADPROC procedure, bool &stop, uint8 channel )
{
    HANDLE handle = 0;

    if( !procedure ) return handle;

    stop = false;

    // prepare work structure 
    ThreadWork *msgwork = new ThreadWork;
    msgwork->channel = channel;
    msgwork->conn_id = conn_id;
    msgwork->vmp4    = is_vmp4( infos.DeviceCode );
    msgwork->hwnd    = m_hWnd;
    msgwork->stop    = &stop;

    // start suspended
    CWinThread* thread = AfxBeginThread( procedure, msgwork, 0, 0, CREATE_SUSPENDED, 0 );  
    if( thread ){
        // grab the handle
        handle = thread->m_hThread; // could be just "thread" which will be operator-casted to HANDLE type
        // resume thread
        thread->ResumeThread();
    }
    return handle;
}

void CMFCSample::tearDownThread( HANDLE &handle, bool &stop )
{
    if( handle != 0 ){
        stop = true; // will tell  the thread to stop

        // We wait for 30s, because the DLL will only report a connection problem after
        // ~20 seconds. We have to be sure to catch that.

        BeginWaitCursor();

        int status = WaitForSingleObject( handle, 30000 );

        EndWaitCursor();

        if( status == WAIT_TIMEOUT ) {
            // happens when the machine got disconnected, kill the culprit
            log(L"Timeout on %s thread, killing it", (handle == msg_thread_handle) ? L"messages" : L"data");
            TerminateThread( handle, -1 );
        } else if ( status != WAIT_OBJECT_0 ){
            DWORD err = GetLastError();
            CString msg;
            msg.Format(L"Thread end error: status = %d, last error: %u, quitting", status, err);
            DisplayPopup(msg, true);
        }
        handle = 0;
    }
}

void CMFCSample::log( PCTSTR format, ... ){
    CString log_content;
    CString msg;

    va_list ap;
    va_start(ap, format);
    msg.FormatV(format, ap);
    va_end(ap);

    logmsg.GetWindowTextW(log_content);
    log_content.Append( msg );
    log_content.Append( L"\r\n" );
    logmsg.SetWindowTextW( log_content );
    logmsg.LineScroll( logmsg.GetLineCount());
}

/** This function sets up the parameters for an OCV technique pass */
static int s_set_OcvParameters(TEccParams_t* params, BOOL vmp4, CString &file, int xrec)
{
    int status = ERR_NOERROR;
    params->len = 5;
    TEccParam_t   *param_list = new TEccParam_t[params->len];
    memset( param_list, 0, params->len * sizeof(TEccParam_t) );

    params->pParams = param_list;
    file = eclab_path + (vmp4 ? L"ocv4.ecc" : L"ocv.ecc");

    /* setup parameters */
    status |= BL_DefineSglParameter( "Rest_time_T",     10.0f, 0, &param_list[0] );
    status |= BL_DefineSglParameter( "Record_every_dE",  0.1f, 0, &param_list[1] );
    status |= BL_DefineSglParameter( "Record_every_dT", 0.01f, 0, &param_list[2] );
    status |= BL_DefineIntParameter( "E_Range", KBIO_ERANGE_AUTO, 0, &param_list[3] );
    status |= BL_DefineIntParameter( "xctr",             xrec, 0,    &param_list[4] );
    return status;
}

/** This function sets up the parameters for a ChronoPotentiometry technique pass */
static int s_setCPParameters(TEccParams_t* params, BOOL vmp4, CString &file, int xrec)
{
    int status = ERR_NOERROR;
    params->len = 17;
    TEccParam_t   *param_list = new TEccParam_t[params->len];
    memset( param_list, 0, params->len * sizeof(TEccParam_t) );

    params->pParams = param_list;
    file = eclab_path + (vmp4 ? L"cp4.ecc" : L"cp.ecc");
    /* setup parameters */
    //{Step #0}
    status |= BL_DefineSglParameter ("Current_step",   0.002f,   0, &param_list[0]); //   {I0 (A)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE,    0, &param_list[1]); //   {vs. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.1f,     0, &param_list[2]); //   {Step duration (s)}
    //{Step #1}
    status |= BL_DefineSglParameter ("Current_step",   -0.001f,  1, &param_list[3]); //   {I1 (A)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE,    1, &param_list[4]); //   {scan to E1 s. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.2f,     1, &param_list[5]); //   {Step duration (s)
    //{Step #2}
    status |= BL_DefineSglParameter ("Current_step",   0.004f,   2, &param_list[6]); //   {I2 (A)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE,    2, &param_list[7]); //   {vs. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.1f,     2, &param_list[8]); //   {Step duration (s)}
    //{others}
    status |= BL_DefineIntParameter ("Step_number",    2,        0, &param_list[9]); //   {step number}
    status |= BL_DefineIntParameter ("N_Cycles",       0,        0, &param_list[10]); //  {cycle Nc time}
    status |= BL_DefineSglParameter ("Record_every_dE",0.1f,     0, &param_list[11]); //  {record every dE (V)}
    status |= BL_DefineSglParameter ("Record_every_dT",0.01f,    0, &param_list[12]); //  {or every dT (s)}
    status |= BL_DefineIntParameter ("I_Range",        KBIO_IRANGE_10mA, 0, &param_list[13]); //  {I Range}
    status |= BL_DefineIntParameter ("E_Range",        KBIO_ERANGE_AUTO, 0, &param_list[14]); //  {E Range}
    status |= BL_DefineIntParameter ("Bandwidth",      KBIO_BW_5, 0, &param_list[15]); //  {bandwidth}
    status |= BL_DefineIntParameter( "xctr",             xrec, 0,    &param_list[16] );
    return status;
}

/** This function sets up the parameters for a ChronoAmperometry technique pass */
static int s_setCAParameters(TEccParams_t* params, BOOL vmp4, CString &file, int xrec)
{
    int status = ERR_NOERROR;
    params->len = 17;
    TEccParam_t   *param_list = new TEccParam_t[params->len];
    memset( param_list, 0, params->len * sizeof(TEccParam_t) );

    params->pParams = param_list;
    file = eclab_path + (vmp4? L"ca4.ecc" : L"ca.ecc");
    //{Step #0}
    status |= BL_DefineSglParameter ("Voltage_step",   1.5f,  0, &param_list[0]); //   {E0 (V)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE, 0, &param_list[1]); //   {vs. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.1f,  0, &param_list[2]); //   {Step duration (s)}
    //{Step #1}
    status |= BL_DefineSglParameter ("Voltage_step",   -1.0f, 1, &param_list[3]); //   {E1 (V)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE, 1, &param_list[4]); //   {scan to E1 s. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.2f,  1, &param_list[5]); //   {Step duration (s)
    //{Step #2}
    status |= BL_DefineSglParameter ("Voltage_step",   2.0f,  2, &param_list[6]); //   {E2 (V)}
    status |= BL_DefineBoolParameter("vs_initial",     FALSE, 2, &param_list[7]); //   {vs. init}
    status |= BL_DefineSglParameter ("Duration_step",  0.1f,  2, &param_list[8]); //   {Step duration (s)}
    //{others}
    status |= BL_DefineIntParameter ("Step_number",    2,     0, &param_list[9]); //   {step number}
    status |= BL_DefineIntParameter ("N_Cycles",       0,     0, &param_list[10]); //  {cycle Nc time}
    status |= BL_DefineSglParameter ("Record_every_dI",0.1f,  0, &param_list[11]); //  {record every dI (A)}
    status |= BL_DefineSglParameter ("Record_every_dT",0.01f, 0, &param_list[12]); //  {or every dT (s)}
    status |= BL_DefineIntParameter ("I_Range",        KBIO_IRANGE_AUTO, 0, &param_list[13]); //  {I Range}
    status |= BL_DefineIntParameter ("E_Range",        KBIO_ERANGE_AUTO, 0, &param_list[14]); //  {E Range}
    status |= BL_DefineIntParameter ("Bandwidth",      KBIO_BW_5, 0, &param_list[15]); //  {bandwidth}
    status |= BL_DefineIntParameter( "xctr",             xrec, 0,    &param_list[16] );
    return status;
}

/** function to get data for OCV techniques */
int CMFCSample::insertOCVData( const TDataBuffer_t& dbuf, const TDataInfos_t& inf, const TCurrentValues_t& curr )
{
    int status = ERR_NOERROR;

    if( inf.NbRows != 0 && inf.NbCols >= 3 ){ /* we expect 3 rows for vmp4 devices, 4 for vmp3 */
        for( int i=0; i< inf.NbRows; i++ ){
            int offset = i * inf.NbCols;
            // see PDF for a description of the data layout
            UINT32 t_high = dbuf.data[offset + 0];
            UINT32 t_low  = dbuf.data[offset + 1];
            UINT32 ewe    = dbuf.data[offset + 2];
            UINT64 t_64   = ((UINT64)(t_high) << 32) + t_low;

            DOUBLE time   = inf.StartTime + curr.TimeBase * t_64;
            FLOAT  f_ewe  = 0.0f;
            CString str;
            status = BL_ConvertNumericIntoSingle( ewe, &f_ewe );
            if( status == ERR_NOERROR ){
                int nbrows = list_ctrl.GetItemCount();
                int colidx = 0;
                
                list_ctrl.InsertItem(nbrows,str, 0);

                str.Format(L"%d", nbrows );
                list_ctrl.SetItemText(nbrows, colidx++, str);
                str.Format(L"%g", time);
                list_ctrl.SetItemText(nbrows, colidx++, str);                    
                str.Format(L"%g", f_ewe);
                list_ctrl.SetItemText(nbrows, colidx++, str);     

                if( inf.NbCols > 3 ){
                    // insert any additionnal value recorded
                    for( int k = 3; k<inf.NbCols; k++){
                        UINT32 additional = dbuf.data[offset + k];
                        FLOAT f_additional = 0.0f;
                        status = BL_ConvertNumericIntoSingle( additional, &f_additional );
                        if( status == ERR_NOERROR ){
                            str.Format(L"%g", f_additional);
                            list_ctrl.SetItemText(nbrows, colidx++, str);    
                        }
                    }
                }
            }
        }
    }
    return status;
}

/** function to get data from CA and CP techniques */
int CMFCSample::insertChronoData( const TDataBuffer_t& dbuf, const TDataInfos_t& inf, const TCurrentValues_t& curr )
{
    int status = ERR_NOERROR;
    if( inf.NbRows != 0 && inf.NbCols >= 5 ){ /* we expect 5 rows for CP and CA */
        for( int i=0; i< inf.NbRows; i++ ){
            int offset = i*inf.NbCols;
            // see PDF for a description of the data layout
            FLOAT  f_ewe  = 0.0f, f_I = 0.0f;
            UINT32 t_high = dbuf.data[offset + 0];
            UINT32 t_low  = dbuf.data[offset + 1];
            UINT32 ewe    = dbuf.data[offset + 2];
            UINT32 I      = dbuf.data[offset + 3];
            UINT32 cycle  = dbuf.data[offset + 4];

            UINT64 t_64   = ((UINT64)(t_high) << 32) + t_low;
            DOUBLE time   = inf.StartTime + curr.TimeBase * t_64;

            status  = BL_ConvertNumericIntoSingle( ewe, &f_ewe );
            status |= BL_ConvertNumericIntoSingle( I, &f_I );

            if( status == ERR_NOERROR ){
                CString str;
                int nbrows = list_ctrl.GetItemCount();
                int colidx = 0;

                list_ctrl.InsertItem(nbrows, str, 0);

                str.Format(L"%d", nbrows );
                list_ctrl.SetItemText(nbrows, colidx++, str);
                str.Format(L"%g", time);
                list_ctrl.SetItemText(nbrows, colidx++, str);                    
                str.Format(L"%g", f_ewe);
                list_ctrl.SetItemText(nbrows, colidx++, str);     
                str.Format(L"%g", f_I);
                list_ctrl.SetItemText(nbrows, colidx++, str);     
                str.Format(L"%d", cycle);
                list_ctrl.SetItemText(nbrows, colidx++, str);     

                if( inf.NbCols > 5 ){
                    // insert any additionnal value recorded
                    for( int k = 5; k<inf.NbCols; k++){
                        UINT32 additional = dbuf.data[offset + k];
                        FLOAT f_additional = 0.0f;
                        status = BL_ConvertNumericIntoSingle( additional, &f_additional );
                        if( status == ERR_NOERROR ){
                            str.Format(L"%g", f_additional);
                        } else {
                            str.Format(L"N/A");
                        }
                        list_ctrl.SetItemText(nbrows, colidx++, str);    
                    }
                }
            }
        }
    }
    return status;
}

UINT CMFCSample::populateData( PVOID data ){
    ThreadWork* work = static_cast<ThreadWork *>(data);

    if( !work || !work->hwnd || work->conn_id == -1 ) return -1;

    int status = ERR_NOERROR;
    BOOL stop = false;
    int total = 0;

    while( !stop ){
        ThreadWorkData* tdata = new ThreadWorkData;
        status = BL_GetData( work->conn_id, work->channel, &tdata->buf, &tdata->infos, &tdata->curr );
        if( status == ERR_NOERROR ) {

            total += tdata->infos.NbRows;
            tdata->total = total;
            // send back to the main thread the data we've collected (giving it the control of tdata)
            FromHandle( work->hwnd )->PostMessage( UWM_UPDATE_RESULTS, 0, (LPARAM)tdata);

      if( *(work->stop) ) {
                status |= BL_StopChannel( work->conn_id, work->channel);
        stop = true;
      } else if (tdata->curr.State != KBIO_STATE_RUN && tdata->infos.NbRows == 0){
        // experiment finished and no more data to retrieve
        stop = true;
      }
    } else {
      CString *errdata = new CString;
      errdata->Format(L"An error in BL_GetData occured: %d", status);
      FromHandle( work->hwnd )->PostMessage( UWM_MESSAGE_RECEIVED, 0, (LPARAM)errdata);
      delete tdata;
      stop = true;
    }

    } // while

    // tell the main thread we've finished our work
    FromHandle( work->hwnd )->PostMessage( UWM_POPULATE_FINISHED, DATA_THREAD, status);
    delete work;
    return 0;
}

UINT CMFCSample::getBLMessages( PVOID data ){
    ThreadWork* work = static_cast<ThreadWork *>(data);
    if( !work || !work->hwnd || work->conn_id == -1 ) return -1;

    CString *announce = new CString;
    announce->SetString(L"Starting messages thread on channel ");
    announce->AppendChar(work->channel + '0' /* int_value + '0' = 'int_value' */);
    FromHandle( work->hwnd )->PostMessage( UWM_MESSAGE_RECEIVED, 0, (LPARAM)announce);

    CHAR msg[1024];
    UINT msg_len = 1024;
    int status = ERR_NOERROR;
    while( !(*work->stop) ){
        memset( msg, 0, 1024 );
        msg_len = 1024;
        status = BL_GetMessage( work->conn_id, work->channel, msg, &msg_len );
        if( status == ERR_NOERROR && msg[0] != '\0' ){
            CString *tdata = new CString;
            tdata->SetString( CString(msg) );
            FromHandle( work->hwnd )->PostMessage( UWM_MESSAGE_RECEIVED, 0, (LPARAM)tdata);
        } else if( status == ERR_GEN_FUNCTIONINPROGRESS ){
            CString *errdata = new CString;
            errdata->Format(L"Concurrent call with BL_GetMessage occured: %d", status);
            FromHandle( work->hwnd )->PostMessage( UWM_MESSAGE_RECEIVED, 0, (LPARAM)errdata);
        } else if( status != ERR_NOERROR ){
            CString *errdata = new CString;
            errdata->Format(L"An error in BL_GetMessage occured: %d", status);
            FromHandle( work->hwnd )->PostMessage( UWM_MESSAGE_RECEIVED, 0, (LPARAM)errdata);
            break; // an error is most likely due to a deconnection, abort
        }
    }
    // tell the main thread we've finished our work
    FromHandle( work->hwnd )->PostMessage( UWM_POPULATE_FINISHED, MESSAGE_THREAD, status);

    delete work;
    return 0;
}

static bool first_pass = true;
LRESULT CMFCSample::OnUpdateData(WPARAM wp, LPARAM lp)
{
    ThreadWorkData *tdata = (ThreadWorkData *)lp;

    if( tdata ){

        if( first_pass ){
            log(L"Columns in data: %d", tdata->infos.NbCols );
            first_pass = false;
        }

        switch( tdata->infos.TechniqueID )
        {
        case KBIO_TECHID_OCV:
            insertOCVData(tdata->buf, tdata->infos, tdata->curr);
            break;
        case KBIO_TECHID_CA: /* CP and CA share the same data format */
        case KBIO_TECHID_CP:
            insertChronoData(tdata->buf, tdata->infos, tdata->curr);
            break;
        default: /* do nothing */
            break;
        }
        CString p;
        p.Format( L"%d", tdata->total );
        point_count.SetWindowTextW( p );
                
        delete tdata;
    }
    return 0;
}

LRESULT CMFCSample::OnPopulateFinished(WPARAM wp, LPARAM lp)
{
    TErrorCodes_e status = (TErrorCodes_e)lp;
    ThreadId          id = (ThreadId)wp;
  
    if( id == MESSAGE_THREAD ) 
    { 
        log(L"Message thread finished\n");
        msg_thread_handle = 0;
    } 
    else if( id == DATA_THREAD )
    { 
        log(L"Acquisition thread finished\n");
        data_thread_handle = 0;
        // reset the buttons
        OnStopClicked();
        first_pass = true;
    }

    if( status != ERR_NOERROR ){
       DisplayPopupDisconnect(L"An error occured in the threads, abort!\r\n(this could freeze the UI for ~20s)", status );
    }

    return 0;
}

LRESULT CMFCSample::OnVMPMessage(WPARAM wp, LPARAM lp){
    CString *tdata = (CString *)lp;
    if( tdata ){
        CString logtxt;
        logmsg.GetWindowTextW( logtxt );
        logtxt.Append( *tdata );
        logtxt.Append( L"\r\n" );
        logmsg.SetWindowTextW(logtxt);
        logmsg.LineScroll( logmsg.GetLineCount());

        delete tdata;
    }
    return 0;
}

void CMFCSample::OnQuitClicked()
{
    if( conn_id != -1 ){ // cleanup
        OnStopClicked();
        OnDisconnectClicked();
    }
    PostQuitMessage( 0 );
}

void CMFCSample::OnConnectClicked()
{
    CString ip;
    ip_address.GetWindowTextW( ip );
    log(L"Connect to %s\n", ip);
    if( !ip.IsEmpty() ){
        if( BL_Connect( CStringA(ip), 10, &conn_id, &infos ) != ERR_NOERROR ){
            // error
            DisplayPopup(TEXT("Error connecting to the device, try another ip."));
        } else {
            log(L"ID = %d\n", conn_id);
            setupChannels();
            info_btn.EnableWindow( true );
            connect_btn.EnableWindow( false );
            disconnect_btn.EnableWindow( true );
            conn_status.SetWindowTextW(TEXT("Connected"));
            
            // launch/relaunchlaunch thread to get messages on current channel
            tearDownThread(msg_thread_handle, stop_messages);
            msg_thread_handle = createThread( getBLMessages, stop_messages, getCurrentChannel() );
        }
    }
}

void CMFCSample::OnInfoClicked()
{
    if( conn_id != -1 ){
        CString msg; 
        msg.Format(L"Id: %d Code: %d\nRam: %d, CPU %d\nFirmware: v%d from %d/%d/%d",
                 conn_id, infos.DeviceCode, infos.RAMSize, infos.CPU, infos.FirmwareVersion,
                 infos.FirmwareDate_dd, infos.FirmwareDate_mm, infos.FirmwareDate_yyyy);
        DisplayPopup( msg );
    }
}

void CMFCSample::OnDisconnectClicked()
{
    if( conn_id != -1 ){
        // simulate a stop press
        OnStopClicked();
        // wait for msg thread to finish
        tearDownThread( msg_thread_handle, stop_messages);

        if( BL_Disconnect( conn_id ) != ERR_NOERROR )
            DisplayPopup(TEXT("Error disconnecting from the device."), true);

        conn_id = -1;

        // reset buttons
        connect_btn.EnableWindow( true );
        info_btn.EnableWindow( false );
        disconnect_btn.EnableWindow( false );
        quit_btn.EnableWindow( true );
        conn_status.SetWindowTextW(TEXT("Disconnected"));
        channel_list.ResetContent();
    }
}

void CMFCSample::OnChanInfoClicked()
{
    TChannelInfos_t cinfos;
    uint8 c = getCurrentChannel();
    log(L"Asking infos on channel %d\n", c);

    if( c == -1 ){
        DisplayPopup(L"No Channel selected");
        return;
    }

    int err = BL_GetChannelInfos( conn_id, c, &cinfos );
    if( err == ERR_NOERROR ) {
        CString msg;
        msg.Format(L"Board Version: %d Board SN: %d\nFWCode: %d, FWVersion: %d\nAmpcode: %d",
            cinfos.BoardVersion, cinfos.BoardSerialNumber, 
            cinfos.FirmwareCode, cinfos.FirmwareVersion, cinfos.AmpCode);
        DisplayPopup( msg );
    } else {
        DisplayPopupDisconnect(L"BL_GetChannelInfos failed", err );
    }
}

void CMFCSample::OnChanCurrentValueClicked()
{
    TCurrentValues_t cvalues;
    uint8 c = getCurrentChannel();

    if( c == -1 ){
        DisplayPopup(L"No Channel selected");
        return;
    }

    int err = BL_GetCurrentValues( conn_id, c, &cvalues );
    if( err == ERR_NOERROR ) {
        CString msg;
        msg.Format(L"State:%d Memfilled %d\nEwe: %f Ece %f\nI %f Elapsed time %f",
                 cvalues.State, cvalues.MemFilled, cvalues.Ewe, 
                 cvalues.Ece,   cvalues.I,         cvalues.ElapsedTime);
        DisplayPopup( msg );
    } else {
        DisplayPopupDisconnect(L"BL_GetCurrentValues failed", err );
    }
}

void CMFCSample::OnStartClicked()
{
    int           status = ERR_NOERROR;
    CString       tech_file;
    CString       technique;
    TEccParams_t  params = { 0, 0 }; // empty params
    bool          vmp4 = is_vmp4(infos.DeviceCode);
    uint8         ch = getCurrentChannel();
    int           xrec = getXrec(); 

    log(L"xrec value: %02X\n", xrec);

    techniques_list.GetLBText( techniques_list.GetCurSel(), technique );

    setupDataList( technique, vmp4, xrec );
     if( technique == "OCV" ){ 
        status = s_set_OcvParameters(&params, vmp4, tech_file, xrec);
    } else if (technique == "ChronoPotentiometry" ) {
        status = s_setCPParameters(&params, vmp4, tech_file, xrec);
    } else if (technique == "ChronoAmperometry" ) {
        status = s_setCAParameters(&params, vmp4, tech_file, xrec);
    }

    if( status == ERR_NOERROR && params.len != 0 && tech_file[0] != '\0' && ch != -1 ){
        log(L"Technique to load: %s to channel %d\n", tech_file, ch );
        bool show_pars = ( BST_CHECKED == show_params.GetCheck() );
        status = BL_LoadTechnique( conn_id, ch, CStringA(tech_file), params, true, true, show_pars );

        if( status != ERR_NOERROR ){
            CString errmsg;
            errmsg.Format(L"Load Technique failed, err %d", status );
            DisplayPopup(errmsg);
        } else {
            if( BL_StartChannel( conn_id, ch ) == ERR_NOERROR ){
                // setup buttons                
                started_status.SetWindowTextW(L"Started");
                start_btn.EnableWindow( false );
                stop_btn.EnableWindow( true );
                quit_btn.EnableWindow(false);

                // start acq thread
                tearDownThread( data_thread_handle, stop_acq );
                data_thread_handle = createThread( populateData, stop_acq, ch );
            } else  {
                DisplayPopupDisconnect(L"BL_StartChannel failed", status);
            }
        }
    }
    // cleanup allocated memory
    if(params.pParams != 0){
        delete[] params.pParams;
    }
}

void CMFCSample::OnStopClicked()
{
    // stop the acq thread and reset the buttons
    if( data_thread_handle != 0 )
        tearDownThread( data_thread_handle, stop_acq );

    start_btn.EnableWindow( true );
    stop_btn.EnableWindow( false );
    quit_btn.EnableWindow( true );
    started_status.SetWindowTextW(L"Stopped");
}

void CMFCSample::OnBnClickedButtonCopy()
{
    int rows = list_ctrl.GetItemCount();
    int cols = list_ctrl.GetHeaderCtrl()->GetItemCount();
    CString clipboard;

    // Get column names in <colname>,<colname2>, ... format
    TCHAR name[40];
    LVCOLUMN col;
    col.mask=LVCF_TEXT;
    col.pszText=name;
    col.cchTextMax=40;
    for( int c = 0; c<cols; c++ ){
        if( list_ctrl.GetColumn(c, &col) ){
            clipboard += col.pszText;
            clipboard += ",";
        } else {
            clipboard += "?,";
        }
    }
    clipboard += "\r\n";

    // get data in <data1>,<data2>, ...
    for( int r = 0; r<rows; r++ ){
        for( int c = 0; c<cols; c++ ){
            clipboard += list_ctrl.GetItemText(r,c);
            clipboard += ",";
        }
        clipboard += "\r\n";
    }

    // copy to clipboard
    HGLOBAL h;
    LPTSTR arr;

    size_t bytes = (clipboard.GetLength()+1)*sizeof(TCHAR);
    h=GlobalAlloc(GMEM_MOVEABLE, bytes);
    arr=(LPTSTR)GlobalLock(h);
    ZeroMemory(arr,bytes);
    _tcscpy_s(arr, clipboard.GetLength()+1, clipboard);
    clipboard.ReleaseBuffer();
    GlobalUnlock(h);

    ::OpenClipboard (NULL);
    EmptyClipboard();
    SetClipboardData(CF_UNICODETEXT, h);
    CloseClipboard();

    log(L"Copied data from results to the clipboard");
}


void CMFCSample::OnChannelSelectionChanged()
{
    uint8 ch = getCurrentChannel();
    tearDownThread(msg_thread_handle, stop_messages);
    if( ch != -1 ){
        msg_thread_handle = createThread( getBLMessages, stop_messages, ch );
    }
}
